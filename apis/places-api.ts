/* tslint:disable */
/* eslint-disable */
/**
 * eHelply SDK - 1.1.87
 * eHelply SDK for SuperStack Services
 *
 * The version of the OpenAPI document: 1.1.87
 * Contact: support@ehelply.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { Page } from '../models';
// @ts-ignore
import { PlaceBase } from '../models';
// @ts-ignore
import { PlaceResponse } from '../models';
/**
 * PlacesApi - axios parameter creator
 * @export
 */
export const PlacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlacePlacesPlacesPost: async (placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeBase' is not null or undefined
            assertParamExists('createPlacePlacesPlacesPost', 'placeBase', placeBase)
            const localVarPath = `/places/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlacePlacesPlacesPlaceUuidDelete: async (placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('deletePlacePlacesPlacesPlaceUuidDelete', 'placeUuid', placeUuid)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (softDelete !== undefined) {
                localVarQueryParameter['soft_delete'] = softDelete;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardGeocodingPlacesGeocodingForwardGet: async (searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchingPlace' is not null or undefined
            assertParamExists('forwardGeocodingPlacesGeocodingForwardGet', 'searchingPlace', searchingPlace)
            const localVarPath = `/places/geocoding/forward`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchingPlace !== undefined) {
                localVarQueryParameter['searching_place'] = searchingPlace;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlacePlacesPlacesPlaceUuidGet: async (placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('getPlacePlacesPlacesPlaceUuidGet', 'placeUuid', placeUuid)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withMeta !== undefined) {
                localVarQueryParameter['with_meta'] = withMeta;
            }

            if (withCatalog !== undefined) {
                localVarQueryParameter['with_catalog'] = withCatalog;
            }

            if (withReviews !== undefined) {
                localVarQueryParameter['with_reviews'] = withReviews;
            }

            if (withSchedule !== undefined) {
                localVarQueryParameter['with_schedule'] = withSchedule;
            }

            if (withCollection !== undefined) {
                localVarQueryParameter['with_collection'] = withCollection;
            }

            if (withBlog !== undefined) {
                localVarQueryParameter['with_blog'] = withBlog;
            }

            if (withTags !== undefined) {
                localVarQueryParameter['with_tags'] = withTags;
            }

            if (withCategories !== undefined) {
                localVarQueryParameter['with_categories'] = withCategories;
            }

            if (withCompany !== undefined) {
                localVarQueryParameter['with_company'] = withCompany;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodingPlacesGeocodingReverseGet: async (_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_long' is not null or undefined
            assertParamExists('reverseGeocodingPlacesGeocodingReverseGet', '_long', _long)
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('reverseGeocodingPlacesGeocodingReverseGet', 'lat', lat)
            const localVarPath = `/places/geocoding/reverse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_long !== undefined) {
                localVarQueryParameter['long'] = _long;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesBySearchStringPlacesSearchPlacesStringGet: async (searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/search/places/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchString !== undefined) {
                localVarQueryParameter['search_string'] = searchString;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortOn !== undefined) {
                localVarQueryParameter['sort_on'] = sortOn;
            }

            if (sortDesc !== undefined) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPlacesPlacesGet: async (projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectUuid !== undefined) {
                localVarQueryParameter['project_uuid'] = projectUuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (addressLine1 !== undefined) {
                localVarQueryParameter['address_line_1'] = addressLine1;
            }

            if (addressLine2 !== undefined) {
                localVarQueryParameter['address_line_2'] = addressLine2;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (provinceState !== undefined) {
                localVarQueryParameter['province_state'] = provinceState;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (postalZipCode !== undefined) {
                localVarQueryParameter['postal_zip_code'] = postalZipCode;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (withCompany !== undefined) {
                localVarQueryParameter['with_company'] = withCompany;
            }

            if (withMeta !== undefined) {
                localVarQueryParameter['with_meta'] = withMeta;
            }

            if (withCatalog !== undefined) {
                localVarQueryParameter['with_catalog'] = withCatalog;
            }

            if (withReviews !== undefined) {
                localVarQueryParameter['with_reviews'] = withReviews;
            }

            if (withSchedule !== undefined) {
                localVarQueryParameter['with_schedule'] = withSchedule;
            }

            if (withCollection !== undefined) {
                localVarQueryParameter['with_collection'] = withCollection;
            }

            if (withBlog !== undefined) {
                localVarQueryParameter['with_blog'] = withBlog;
            }

            if (withTags !== undefined) {
                localVarQueryParameter['with_tags'] = withTags;
            }

            if (withCategories !== undefined) {
                localVarQueryParameter['with_categories'] = withCategories;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortOn !== undefined) {
                localVarQueryParameter['sort_on'] = sortOn;
            }

            if (sortDesc !== undefined) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlacePlacesPlacesPlaceUuidPut: async (placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('updatePlacePlacesPlacesPlaceUuidPut', 'placeUuid', placeUuid)
            // verify required parameter 'placeBase' is not null or undefined
            assertParamExists('updatePlacePlacesPlacesPlaceUuidPut', 'placeBase', placeBase)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlacesApi - functional programming interface
 * @export
 */
export const PlacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forwardGeocodingPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardGeocodingPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseGeocodingPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseGeocodingPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlacesApi - factory interface
 * @export
 */
export const PlacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlacesApiFp(configuration)
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardGeocodingPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.forwardGeocodingPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodingPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseGeocodingPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<Page> {
            return localVarFp.searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<Page> {
            return localVarFp.searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlacesApi - interface
 * @export
 * @interface PlacesApi
 */
export interface PlacesApiInterface {
    /**
     * Creates a Place.
     * @summary Create Place
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

    /**
     * Deletes the place with the given ID and returns True if successful
     * @summary Delete Place
     * @param {string} placeUuid 
     * @param {boolean} [softDelete] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Forward Geocoding
     * @param {string} searchingPlace 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    forwardGeocodingPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * Gets the place information given the Place ID
     * @summary Get Place
     * @param {string} placeUuid 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {boolean} [withCompany] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

    /**
     * 
     * @summary Reverse Geocoding
     * @param {number} _long 
     * @param {number} lat 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    reverseGeocodingPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * Search places by a search string
     * @summary Search Places By Search String
     * @param {string} [searchString] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<Page>;

    /**
     * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
     * @summary Search Places
     * @param {string} [projectUuid] 
     * @param {string} [name] 
     * @param {string} [addressLine1] 
     * @param {string} [addressLine2] 
     * @param {string} [city] 
     * @param {string} [provinceState] 
     * @param {string} [country] 
     * @param {string} [postalZipCode] 
     * @param {string} [lat] 
     * @param {string} [lng] 
     * @param {string} [email] 
     * @param {boolean} [isPublic] 
     * @param {boolean} [isDeleted] 
     * @param {boolean} [withCompany] 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<Page>;

    /**
     * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
     * @summary Update Place
     * @param {string} placeUuid 
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

}

/**
 * PlacesApi - object-oriented interface
 * @export
 * @class PlacesApi
 * @extends {BaseAPI}
 */
export class PlacesApi extends BaseAPI implements PlacesApiInterface {
    /**
     * Creates a Place.
     * @summary Create Place
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the place with the given ID and returns True if successful
     * @summary Delete Place
     * @param {string} placeUuid 
     * @param {boolean} [softDelete] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forward Geocoding
     * @param {string} searchingPlace 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public forwardGeocodingPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).forwardGeocodingPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the place information given the Place ID
     * @summary Get Place
     * @param {string} placeUuid 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {boolean} [withCompany] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Geocoding
     * @param {number} _long 
     * @param {number} lat 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public reverseGeocodingPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).reverseGeocodingPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search places by a search string
     * @summary Search Places By Search String
     * @param {string} [searchString] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).searchPlacesBySearchStringPlacesSearchPlacesStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
     * @summary Search Places
     * @param {string} [projectUuid] 
     * @param {string} [name] 
     * @param {string} [addressLine1] 
     * @param {string} [addressLine2] 
     * @param {string} [city] 
     * @param {string} [provinceState] 
     * @param {string} [country] 
     * @param {string} [postalZipCode] 
     * @param {string} [lat] 
     * @param {string} [lng] 
     * @param {string} [email] 
     * @param {boolean} [isPublic] 
     * @param {boolean} [isDeleted] 
     * @param {boolean} [withCompany] 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
     * @summary Update Place
     * @param {string} placeUuid 
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }
}
