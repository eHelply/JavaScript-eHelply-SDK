/* tslint:disable */
/* eslint-disable */
/**
 * eHelply SDK - 1.1.68
 * eHelply SDK for SuperStack Services
 *
 * The version of the OpenAPI document: 1.1.68
 *
 * Do not edit the class manually.
 *
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "[]"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright 2022 eHelply Software Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { HTTPValidationError } from '../models';
// @ts-ignore
import { Page } from '../models';
// @ts-ignore
import { PlaceBase } from '../models';
// @ts-ignore
import { PlaceResponse } from '../models';
/**
 * PlacesApi - axios parameter creator
 * @export
 */
export const PlacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlacePlacesPlacesPost: async (placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeBase' is not null or undefined
            assertParamExists('createPlacePlacesPlacesPost', 'placeBase', placeBase)
            const localVarPath = `/places/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlacePlacesPlacesPlaceUuidDelete: async (placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('deletePlacePlacesPlacesPlaceUuidDelete', 'placeUuid', placeUuid)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (softDelete !== undefined) {
                localVarQueryParameter['soft_delete'] = softDelete;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardGeocodingPlacesPlacesGeocodingForwardGet: async (searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchingPlace' is not null or undefined
            assertParamExists('forwardGeocodingPlacesPlacesGeocodingForwardGet', 'searchingPlace', searchingPlace)
            const localVarPath = `/places/places/geocoding/forward`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchingPlace !== undefined) {
                localVarQueryParameter['searching_place'] = searchingPlace;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlacePlacesPlacesPlaceUuidGet: async (placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('getPlacePlacesPlacesPlaceUuidGet', 'placeUuid', placeUuid)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withMeta !== undefined) {
                localVarQueryParameter['with_meta'] = withMeta;
            }

            if (withCatalog !== undefined) {
                localVarQueryParameter['with_catalog'] = withCatalog;
            }

            if (withReviews !== undefined) {
                localVarQueryParameter['with_reviews'] = withReviews;
            }

            if (withSchedule !== undefined) {
                localVarQueryParameter['with_schedule'] = withSchedule;
            }

            if (withCollection !== undefined) {
                localVarQueryParameter['with_collection'] = withCollection;
            }

            if (withBlog !== undefined) {
                localVarQueryParameter['with_blog'] = withBlog;
            }

            if (withTags !== undefined) {
                localVarQueryParameter['with_tags'] = withTags;
            }

            if (withCategories !== undefined) {
                localVarQueryParameter['with_categories'] = withCategories;
            }

            if (withCompany !== undefined) {
                localVarQueryParameter['with_company'] = withCompany;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodingPlacesPlacesGeocodingReverseGet: async (_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_long' is not null or undefined
            assertParamExists('reverseGeocodingPlacesPlacesGeocodingReverseGet', '_long', _long)
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('reverseGeocodingPlacesPlacesGeocodingReverseGet', 'lat', lat)
            const localVarPath = `/places/places/geocoding/reverse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_long !== undefined) {
                localVarQueryParameter['long'] = _long;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesBySearchStringPlacesPlacesSearchStringGet: async (searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/places/search/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchString !== undefined) {
                localVarQueryParameter['search_string'] = searchString;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortOn !== undefined) {
                localVarQueryParameter['sort_on'] = sortOn;
            }

            if (sortDesc !== undefined) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPlacesPlacesGet: async (projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/places`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectUuid !== undefined) {
                localVarQueryParameter['project_uuid'] = projectUuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (addressLine1 !== undefined) {
                localVarQueryParameter['address_line_1'] = addressLine1;
            }

            if (addressLine2 !== undefined) {
                localVarQueryParameter['address_line_2'] = addressLine2;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (provinceState !== undefined) {
                localVarQueryParameter['province_state'] = provinceState;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (postalZipCode !== undefined) {
                localVarQueryParameter['postal_zip_code'] = postalZipCode;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (withCompany !== undefined) {
                localVarQueryParameter['with_company'] = withCompany;
            }

            if (withMeta !== undefined) {
                localVarQueryParameter['with_meta'] = withMeta;
            }

            if (withCatalog !== undefined) {
                localVarQueryParameter['with_catalog'] = withCatalog;
            }

            if (withReviews !== undefined) {
                localVarQueryParameter['with_reviews'] = withReviews;
            }

            if (withSchedule !== undefined) {
                localVarQueryParameter['with_schedule'] = withSchedule;
            }

            if (withCollection !== undefined) {
                localVarQueryParameter['with_collection'] = withCollection;
            }

            if (withBlog !== undefined) {
                localVarQueryParameter['with_blog'] = withBlog;
            }

            if (withTags !== undefined) {
                localVarQueryParameter['with_tags'] = withTags;
            }

            if (withCategories !== undefined) {
                localVarQueryParameter['with_categories'] = withCategories;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (sortOn !== undefined) {
                localVarQueryParameter['sort_on'] = sortOn;
            }

            if (sortDesc !== undefined) {
                localVarQueryParameter['sort_desc'] = sortDesc;
            }

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlacePlacesPlacesPlaceUuidPut: async (placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeUuid' is not null or undefined
            assertParamExists('updatePlacePlacesPlacesPlaceUuidPut', 'placeUuid', placeUuid)
            // verify required parameter 'placeBase' is not null or undefined
            assertParamExists('updatePlacePlacesPlacesPlaceUuidPut', 'placeBase', placeBase)
            const localVarPath = `/places/places/{place_uuid}`
                .replace(`{${"place_uuid"}}`, encodeURIComponent(String(placeUuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAccessToken !== undefined && xAccessToken !== null) {
                localVarHeaderParameter['x-access-token'] = String(xAccessToken);
            }

            if (xSecretToken !== undefined && xSecretToken !== null) {
                localVarHeaderParameter['x-secret-token'] = String(xSecretToken);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }

            if (ehelplyActiveParticipant !== undefined && ehelplyActiveParticipant !== null) {
                localVarHeaderParameter['ehelply-active-participant'] = String(ehelplyActiveParticipant);
            }

            if (ehelplyProject !== undefined && ehelplyProject !== null) {
                localVarHeaderParameter['ehelply-project'] = String(ehelplyProject);
            }

            if (ehelplyData !== undefined && ehelplyData !== null) {
                localVarHeaderParameter['ehelply-data'] = String(ehelplyData);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeBase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlacesApi - functional programming interface
 * @export
 */
export const PlacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseGeocodingPlacesPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseGeocodingPlacesPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlacesApi - factory interface
 * @export
 */
export const PlacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlacesApiFp(configuration)
    return {
        /**
         * Creates a Place.
         * @summary Create Place
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the place with the given ID and returns True if successful
         * @summary Delete Place
         * @param {string} placeUuid 
         * @param {boolean} [softDelete] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forward Geocoding
         * @param {string} searchingPlace 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the place information given the Place ID
         * @summary Get Place
         * @param {string} placeUuid 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {boolean} [withCompany] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Geocoding
         * @param {number} _long 
         * @param {number} lat 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseGeocodingPlacesPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseGeocodingPlacesPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search places by a search string
         * @summary Search Places By Search String
         * @param {string} [searchString] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<Page> {
            return localVarFp.searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
         * @summary Search Places
         * @param {string} [projectUuid] 
         * @param {string} [name] 
         * @param {string} [addressLine1] 
         * @param {string} [addressLine2] 
         * @param {string} [city] 
         * @param {string} [provinceState] 
         * @param {string} [country] 
         * @param {string} [postalZipCode] 
         * @param {string} [lat] 
         * @param {string} [lng] 
         * @param {string} [email] 
         * @param {boolean} [isPublic] 
         * @param {boolean} [isDeleted] 
         * @param {boolean} [withCompany] 
         * @param {boolean} [withMeta] 
         * @param {boolean} [withCatalog] 
         * @param {boolean} [withReviews] 
         * @param {boolean} [withSchedule] 
         * @param {boolean} [withCollection] 
         * @param {boolean} [withBlog] 
         * @param {boolean} [withTags] 
         * @param {boolean} [withCategories] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [sortOn] 
         * @param {boolean} [sortDesc] 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<Page> {
            return localVarFp.searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
         * @summary Update Place
         * @param {string} placeUuid 
         * @param {PlaceBase} placeBase 
         * @param {string} [xAccessToken] 
         * @param {string} [xSecretToken] 
         * @param {string} [authorization] 
         * @param {string} [ehelplyActiveParticipant] 
         * @param {string} [ehelplyProject] 
         * @param {string} [ehelplyData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: any): AxiosPromise<PlaceResponse> {
            return localVarFp.updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlacesApi - interface
 * @export
 * @interface PlacesApi
 */
export interface PlacesApiInterface {
    /**
     * Creates a Place.
     * @summary Create Place
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

    /**
     * Deletes the place with the given ID and returns True if successful
     * @summary Delete Place
     * @param {string} placeUuid 
     * @param {boolean} [softDelete] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Forward Geocoding
     * @param {string} searchingPlace 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * Gets the place information given the Place ID
     * @summary Get Place
     * @param {string} placeUuid 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {boolean} [withCompany] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

    /**
     * 
     * @summary Reverse Geocoding
     * @param {number} _long 
     * @param {number} lat 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    reverseGeocodingPlacesPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * Search places by a search string
     * @summary Search Places By Search String
     * @param {string} [searchString] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<Page>;

    /**
     * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
     * @summary Search Places
     * @param {string} [projectUuid] 
     * @param {string} [name] 
     * @param {string} [addressLine1] 
     * @param {string} [addressLine2] 
     * @param {string} [city] 
     * @param {string} [provinceState] 
     * @param {string} [country] 
     * @param {string} [postalZipCode] 
     * @param {string} [lat] 
     * @param {string} [lng] 
     * @param {string} [email] 
     * @param {boolean} [isPublic] 
     * @param {boolean} [isDeleted] 
     * @param {boolean} [withCompany] 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<Page>;

    /**
     * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
     * @summary Update Place
     * @param {string} placeUuid 
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApiInterface
     */
    updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig): AxiosPromise<PlaceResponse>;

}

/**
 * PlacesApi - object-oriented interface
 * @export
 * @class PlacesApi
 * @extends {BaseAPI}
 */
export class PlacesApi extends BaseAPI implements PlacesApiInterface {
    /**
     * Creates a Place.
     * @summary Create Place
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public createPlacePlacesPlacesPost(placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).createPlacePlacesPlacesPost(placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the place with the given ID and returns True if successful
     * @summary Delete Place
     * @param {string} placeUuid 
     * @param {boolean} [softDelete] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public deletePlacePlacesPlacesPlaceUuidDelete(placeUuid: string, softDelete?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).deletePlacePlacesPlacesPlaceUuidDelete(placeUuid, softDelete, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forward Geocoding
     * @param {string} searchingPlace 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace: string, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).forwardGeocodingPlacesPlacesGeocodingForwardGet(searchingPlace, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the place information given the Place ID
     * @summary Get Place
     * @param {string} placeUuid 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {boolean} [withCompany] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public getPlacePlacesPlacesPlaceUuidGet(placeUuid: string, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, withCompany?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).getPlacePlacesPlacesPlaceUuidGet(placeUuid, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, withCompany, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Geocoding
     * @param {number} _long 
     * @param {number} lat 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public reverseGeocodingPlacesPlacesGeocodingReverseGet(_long: number, lat: number, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).reverseGeocodingPlacesPlacesGeocodingReverseGet(_long, lat, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search places by a search string
     * @summary Search Places By Search String
     * @param {string} [searchString] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString?: string, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).searchPlacesBySearchStringPlacesPlacesSearchStringGet(searchString, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search all places and returns paginated results with Places being stored in items field. Can search by `project_uuid, name, address, address_line_2, city, province_state, country, postal_zip_code, lat, lng email` string fields or the `is_public and is_deleted` boolean fields. To search with these fields use query params with string values. For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: name). Max pagination items per page is 50. Item return format: ``` {     uuid                                **type:** string     project_uuid                        **type:** string or None      meta_uuid                           **type:** string or None      catalog_data                        **type:** dict or None      review_group_data                   **type:** dict or None      schedule_data                       **type:** dict or None      collection_data                     **type:** dict or None      blog_data                           **type:** dict or None      tags                                **type:** [TagBase] or None      categories                          **type:** [CategoryBase] or None      company                             **type:** CompanyBase or None      created_at                          **type:** string or None      updated_at                          **type:** string or None      deleted_at                          **type:** string or None  } ```
     * @summary Search Places
     * @param {string} [projectUuid] 
     * @param {string} [name] 
     * @param {string} [addressLine1] 
     * @param {string} [addressLine2] 
     * @param {string} [city] 
     * @param {string} [provinceState] 
     * @param {string} [country] 
     * @param {string} [postalZipCode] 
     * @param {string} [lat] 
     * @param {string} [lng] 
     * @param {string} [email] 
     * @param {boolean} [isPublic] 
     * @param {boolean} [isDeleted] 
     * @param {boolean} [withCompany] 
     * @param {boolean} [withMeta] 
     * @param {boolean} [withCatalog] 
     * @param {boolean} [withReviews] 
     * @param {boolean} [withSchedule] 
     * @param {boolean} [withCollection] 
     * @param {boolean} [withBlog] 
     * @param {boolean} [withTags] 
     * @param {boolean} [withCategories] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public searchPlacesPlacesPlacesGet(projectUuid?: string, name?: string, addressLine1?: string, addressLine2?: string, city?: string, provinceState?: string, country?: string, postalZipCode?: string, lat?: string, lng?: string, email?: string, isPublic?: boolean, isDeleted?: boolean, withCompany?: boolean, withMeta?: boolean, withCatalog?: boolean, withReviews?: boolean, withSchedule?: boolean, withCollection?: boolean, withBlog?: boolean, withTags?: boolean, withCategories?: boolean, page?: number, pageSize?: number, sortOn?: string, sortDesc?: boolean, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).searchPlacesPlacesPlacesGet(projectUuid, name, addressLine1, addressLine2, city, provinceState, country, postalZipCode, lat, lng, email, isPublic, isDeleted, withCompany, withMeta, withCatalog, withReviews, withSchedule, withCollection, withBlog, withTags, withCategories, page, pageSize, sortOn, sortDesc, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Place with given info, only updating the fields supplied. Place Uuid must be sent however.
     * @summary Update Place
     * @param {string} placeUuid 
     * @param {PlaceBase} placeBase 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlacesApi
     */
    public updatePlacePlacesPlacesPlaceUuidPut(placeUuid: string, placeBase: PlaceBase, xAccessToken?: string, xSecretToken?: string, authorization?: string, ehelplyActiveParticipant?: string, ehelplyProject?: string, ehelplyData?: string, options?: AxiosRequestConfig) {
        return PlacesApiFp(this.configuration).updatePlacePlacesPlacesPlaceUuidPut(placeUuid, placeBase, xAccessToken, xSecretToken, authorization, ehelplyActiveParticipant, ehelplyProject, ehelplyData, options).then((request) => request(this.axios, this.basePath));
    }
}
