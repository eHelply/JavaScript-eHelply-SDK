/* tslint:disable */
/* eslint-disable */
/**
 * eHelply SDK - 1.1.114
 * eHelply SDK for SuperStack Services
 *
 * The version of the OpenAPI document: 1.1.114
 * Contact: support@ehelply.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    HTTPValidationError,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    Page,
    PageFromJSON,
    PageToJSON,
    ParticipantCreate,
    ParticipantCreateFromJSON,
    ParticipantCreateToJSON,
    ParticipantUpdate,
    ParticipantUpdateFromJSON,
    ParticipantUpdateToJSON,
    ParticipantUserReturn,
    ParticipantUserReturnFromJSON,
    ParticipantUserReturnToJSON,
    User,
    UserFromJSON,
    UserToJSON,
    UserConfirmation,
    UserConfirmationFromJSON,
    UserConfirmationToJSON,
    UserLogin,
    UserLoginFromJSON,
    UserLoginToJSON,
    UserLoginReturn,
    UserLoginReturnFromJSON,
    UserLoginReturnToJSON,
    UserPasswordReset,
    UserPasswordResetFromJSON,
    UserPasswordResetToJSON,
    UserPasswordResetConfirmation,
    UserPasswordResetConfirmationFromJSON,
    UserPasswordResetConfirmationToJSON,
    UserResponse,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSignup,
    UserSignupFromJSON,
    UserSignupToJSON,
    UserSignupReturn,
    UserSignupReturnFromJSON,
    UserSignupReturnToJSON,
    UserTokenReturn,
    UserTokenReturnFromJSON,
    UserTokenReturnToJSON,
    UserValidations,
    UserValidationsFromJSON,
    UserValidationsToJSON,
} from '../models';

export interface ConfirmSignupRequest {
    userConfirmation: UserConfirmation;
}

export interface CreateParticipantRequest {
    participantCreate: ParticipantCreate;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface CreateUserRequest {
    authorization?: string;
}

export interface DeleteParticipantRequest {
    participantId: string;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface DeleteUserRequest {
    userId: string;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface GetParticipantRequest {
    participantId: string;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface GetUserRequest {
    userId: string;
    idType?: string;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface LoginRequest {
    userLogin: UserLogin;
}

export interface RefreshTokenRequest {
    appClient: string;
    body: string;
}

export interface ResetPasswordRequest {
    userPasswordReset: UserPasswordReset;
}

export interface ResetPasswordConfirmationRequest {
    userPasswordResetConfirmation: UserPasswordResetConfirmation;
}

export interface SearchParticipantsRequest {
    page?: number;
    pageSize?: number;
    search?: string;
    searchOn?: string;
    sortOn?: string;
    sortDesc?: boolean;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface SignupRequest {
    userSignup: UserSignup;
}

export interface UpdateParticipantRequest {
    participantId: string;
    participantUpdate: ParticipantUpdate;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface UpdateUserRequest {
    userId: string;
    user: User;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

export interface UserValidationsRequest {
    field: string;
    userValidations: UserValidations;
    xAccessToken?: string;
    xSecretToken?: string;
    authorization?: string;
    ehelplyActiveParticipant?: string;
    ehelplyProject?: string;
    ehelplyData?: string;
}

/**
 * UsersApi - interface
 * 
 * @export
 * @interface UsersApiInterface
 */
export interface UsersApiInterface {
    /**
     * Validates a user signup with a given confirmation
     * @summary Confirmsignup
     * @param {UserConfirmation} userConfirmation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    confirmSignupRaw(requestParameters: ConfirmSignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * Validates a user signup with a given confirmation
     * Confirmsignup
     */
    confirmSignup(requestParameters: ConfirmSignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object>;

    /**
     * Creates a participant given the participant info (meta and user_id)
     * @summary Createparticipant
     * @param {ParticipantCreate} participantCreate 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createParticipantRaw(requestParameters: CreateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>>;

    /**
     * Creates a participant given the participant info (meta and user_id)
     * Createparticipant
     */
    createParticipant(requestParameters: CreateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn>;

    /**
     * Usually ran after login and will do the following: - If no user exists (AKA signed in with social media) it will create a new user and default participant - If a user exists, sync Cognito data from Cognito to the user - Determine missing fields that SHOULD be filled
     * @summary Createuser
     * @param {string} [authorization] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>>;

    /**
     * Usually ran after login and will do the following: - If no user exists (AKA signed in with social media) it will create a new user and default participant - If a user exists, sync Cognito data from Cognito to the user - Determine missing fields that SHOULD be filled
     * Createuser
     */
    createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse>;

    /**
     * Delete participants related to the given participant_id, returns True if successful
     * @summary Deleteparticipant
     * @param {string} participantId 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    deleteParticipantRaw(requestParameters: DeleteParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>>;

    /**
     * Delete participants related to the given participant_id, returns True if successful
     * Deleteparticipant
     */
    deleteParticipant(requestParameters: DeleteParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean>;

    /**
     * Soft deletes the user with the provided user id, granted the deleter is the same person or an admin. Returns True if successful
     * @summary Deleteuser
     * @param {string} userId 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>>;

    /**
     * Soft deletes the user with the provided user id, granted the deleter is the same person or an admin. Returns True if successful
     * Deleteuser
     */
    deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean>;

    /**
     * Gets a participant given their participant ID
     * @summary Getparticipant
     * @param {string} participantId 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getParticipantRaw(requestParameters: GetParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>>;

    /**
     * Gets a participant given their participant ID
     * Getparticipant
     */
    getParticipant(requestParameters: GetParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn>;

    /**
     * Gets the user object given user id (uuid) or cognito id (cognito)
     * @summary Getuser
     * @param {string} userId 
     * @param {string} [idType] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>>;

    /**
     * Gets the user object given user id (uuid) or cognito id (cognito)
     * Getuser
     */
    getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse>;

    /**
     * Login endpoint, returns tokens. EMAIL NEEDS TO BE VERIFIED (can be done through the email the user received).
     * @summary Login
     * @param {UserLogin} userLogin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserLoginReturn>>;

    /**
     * Login endpoint, returns tokens. EMAIL NEEDS TO BE VERIFIED (can be done through the email the user received).
     * Login
     */
    login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserLoginReturn>;

    /**
     * Refreshes tokens given a refresh token.
     * @summary Refreshtoken
     * @param {string} appClient 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    refreshTokenRaw(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserTokenReturn>>;

    /**
     * Refreshes tokens given a refresh token.
     * Refreshtoken
     */
    refreshToken(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserTokenReturn>;

    /**
     * Sends the user an email with a confirmation code so they can reset their password
     * @summary Resetpassword
     * @param {UserPasswordReset} userPasswordReset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    resetPasswordRaw(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * Sends the user an email with a confirmation code so they can reset their password
     * Resetpassword
     */
    resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object>;

    /**
     * Resets the given user\'s password to the given password when the proper code is provided
     * @summary Resetpasswordconfirmation
     * @param {UserPasswordResetConfirmation} userPasswordResetConfirmation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    resetPasswordConfirmationRaw(requestParameters: ResetPasswordConfirmationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * Resets the given user\'s password to the given password when the proper code is provided
     * Resetpasswordconfirmation
     */
    resetPasswordConfirmation(requestParameters: ResetPasswordConfirmationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object>;

    /**
     * Search participants using a user uuid, returns pagination information and list of `items` (ParticipantUserReturn from GET Participant). Can search on \"user_uuid\", and sort on any field. To search enter search value into \"search\" query param and the field into \"search on\" (currently only \"user\"uuid\"). For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: date_created). Max pagination items per page is 50.
     * @summary Searchparticipants
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [search] 
     * @param {string} [searchOn] 
     * @param {string} [sortOn] 
     * @param {boolean} [sortDesc] 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    searchParticipantsRaw(requestParameters: SearchParticipantsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Page>>;

    /**
     * Search participants using a user uuid, returns pagination information and list of `items` (ParticipantUserReturn from GET Participant). Can search on \"user_uuid\", and sort on any field. To search enter search value into \"search\" query param and the field into \"search on\" (currently only \"user\"uuid\"). For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: date_created). Max pagination items per page is 50.
     * Searchparticipants
     */
    searchParticipants(requestParameters: SearchParticipantsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Page>;

    /**
     * Signup to eHelply, creates a user and default participant behind the scenes. Does not verify email.
     * @summary Signup
     * @param {UserSignup} userSignup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    signupRaw(requestParameters: SignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserSignupReturn>>;

    /**
     * Signup to eHelply, creates a user and default participant behind the scenes. Does not verify email.
     * Signup
     */
    signup(requestParameters: SignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserSignupReturn>;

    /**
     * Update participant data given
     * @summary Updateparticipant
     * @param {string} participantId 
     * @param {ParticipantUpdate} participantUpdate 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateParticipantRaw(requestParameters: UpdateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>>;

    /**
     * Update participant data given
     * Updateparticipant
     */
    updateParticipant(requestParameters: UpdateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn>;

    /**
     * Update the given user and sync the cognito data
     * @summary Updateuser
     * @param {string} userId 
     * @param {User} user 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    updateUserRaw(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>>;

    /**
     * Update the given user and sync the cognito data
     * Updateuser
     */
    updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse>;

    /**
     * Validates a certain field.
     * @summary Uservalidations
     * @param {string} field 
     * @param {UserValidations} userValidations 
     * @param {string} [xAccessToken] 
     * @param {string} [xSecretToken] 
     * @param {string} [authorization] 
     * @param {string} [ehelplyActiveParticipant] 
     * @param {string} [ehelplyProject] 
     * @param {string} [ehelplyData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    userValidationsRaw(requestParameters: UserValidationsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>>;

    /**
     * Validates a certain field.
     * Uservalidations
     */
    userValidations(requestParameters: UserValidationsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean>;

}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI implements UsersApiInterface {

    /**
     * Validates a user signup with a given confirmation
     * Confirmsignup
     */
    async confirmSignupRaw(requestParameters: ConfirmSignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userConfirmation === null || requestParameters.userConfirmation === undefined) {
            throw new runtime.RequiredError('userConfirmation','Required parameter requestParameters.userConfirmation was null or undefined when calling confirmSignup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/signup/confirm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserConfirmationToJSON(requestParameters.userConfirmation),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Validates a user signup with a given confirmation
     * Confirmsignup
     */
    async confirmSignup(requestParameters: ConfirmSignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object> {
        const response = await this.confirmSignupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a participant given the participant info (meta and user_id)
     * Createparticipant
     */
    async createParticipantRaw(requestParameters: CreateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>> {
        if (requestParameters.participantCreate === null || requestParameters.participantCreate === undefined) {
            throw new runtime.RequiredError('participantCreate','Required parameter requestParameters.participantCreate was null or undefined when calling createParticipant.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/participants`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ParticipantCreateToJSON(requestParameters.participantCreate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipantUserReturnFromJSON(jsonValue));
    }

    /**
     * Creates a participant given the participant info (meta and user_id)
     * Createparticipant
     */
    async createParticipant(requestParameters: CreateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn> {
        const response = await this.createParticipantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Usually ran after login and will do the following: - If no user exists (AKA signed in with social media) it will create a new user and default participant - If a user exists, sync Cognito data from Cognito to the user - Determine missing fields that SHOULD be filled
     * Createuser
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        const response = await this.request({
            path: `/sam/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Usually ran after login and will do the following: - If no user exists (AKA signed in with social media) it will create a new user and default participant - If a user exists, sync Cognito data from Cognito to the user - Determine missing fields that SHOULD be filled
     * Createuser
     */
    async createUser(requestParameters: CreateUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete participants related to the given participant_id, returns True if successful
     * Deleteparticipant
     */
    async deleteParticipantRaw(requestParameters: DeleteParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.participantId === null || requestParameters.participantId === undefined) {
            throw new runtime.RequiredError('participantId','Required parameter requestParameters.participantId was null or undefined when calling deleteParticipant.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/participants/{participant_id}`.replace(`{${"participant_id"}}`, encodeURIComponent(String(requestParameters.participantId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete participants related to the given participant_id, returns True if successful
     * Deleteparticipant
     */
    async deleteParticipant(requestParameters: DeleteParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean> {
        const response = await this.deleteParticipantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Soft deletes the user with the provided user id, granted the deleter is the same person or an admin. Returns True if successful
     * Deleteuser
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Soft deletes the user with the provided user id, granted the deleter is the same person or an admin. Returns True if successful
     * Deleteuser
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean> {
        const response = await this.deleteUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a participant given their participant ID
     * Getparticipant
     */
    async getParticipantRaw(requestParameters: GetParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>> {
        if (requestParameters.participantId === null || requestParameters.participantId === undefined) {
            throw new runtime.RequiredError('participantId','Required parameter requestParameters.participantId was null or undefined when calling getParticipant.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/participants/{participant_id}`.replace(`{${"participant_id"}}`, encodeURIComponent(String(requestParameters.participantId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipantUserReturnFromJSON(jsonValue));
    }

    /**
     * Gets a participant given their participant ID
     * Getparticipant
     */
    async getParticipant(requestParameters: GetParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn> {
        const response = await this.getParticipantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the user object given user id (uuid) or cognito id (cognito)
     * Getuser
     */
    async getUserRaw(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.idType !== undefined) {
            queryParameters['id_type'] = requestParameters.idType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets the user object given user id (uuid) or cognito id (cognito)
     * Getuser
     */
    async getUser(requestParameters: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse> {
        const response = await this.getUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Login endpoint, returns tokens. EMAIL NEEDS TO BE VERIFIED (can be done through the email the user received).
     * Login
     */
    async loginRaw(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserLoginReturn>> {
        if (requestParameters.userLogin === null || requestParameters.userLogin === undefined) {
            throw new runtime.RequiredError('userLogin','Required parameter requestParameters.userLogin was null or undefined when calling login.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserLoginToJSON(requestParameters.userLogin),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserLoginReturnFromJSON(jsonValue));
    }

    /**
     * Login endpoint, returns tokens. EMAIL NEEDS TO BE VERIFIED (can be done through the email the user received).
     * Login
     */
    async login(requestParameters: LoginRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserLoginReturn> {
        const response = await this.loginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refreshes tokens given a refresh token.
     * Refreshtoken
     */
    async refreshTokenRaw(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserTokenReturn>> {
        if (requestParameters.appClient === null || requestParameters.appClient === undefined) {
            throw new runtime.RequiredError('appClient','Required parameter requestParameters.appClient was null or undefined when calling refreshToken.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling refreshToken.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/{app_client}/refresh-token`.replace(`{${"app_client"}}`, encodeURIComponent(String(requestParameters.appClient))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTokenReturnFromJSON(jsonValue));
    }

    /**
     * Refreshes tokens given a refresh token.
     * Refreshtoken
     */
    async refreshToken(requestParameters: RefreshTokenRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserTokenReturn> {
        const response = await this.refreshTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends the user an email with a confirmation code so they can reset their password
     * Resetpassword
     */
    async resetPasswordRaw(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userPasswordReset === null || requestParameters.userPasswordReset === undefined) {
            throw new runtime.RequiredError('userPasswordReset','Required parameter requestParameters.userPasswordReset was null or undefined when calling resetPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/password/reset`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPasswordResetToJSON(requestParameters.userPasswordReset),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Sends the user an email with a confirmation code so they can reset their password
     * Resetpassword
     */
    async resetPassword(requestParameters: ResetPasswordRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object> {
        const response = await this.resetPasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resets the given user\'s password to the given password when the proper code is provided
     * Resetpasswordconfirmation
     */
    async resetPasswordConfirmationRaw(requestParameters: ResetPasswordConfirmationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userPasswordResetConfirmation === null || requestParameters.userPasswordResetConfirmation === undefined) {
            throw new runtime.RequiredError('userPasswordResetConfirmation','Required parameter requestParameters.userPasswordResetConfirmation was null or undefined when calling resetPasswordConfirmation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/password/reset/confirm`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserPasswordResetConfirmationToJSON(requestParameters.userPasswordResetConfirmation),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Resets the given user\'s password to the given password when the proper code is provided
     * Resetpasswordconfirmation
     */
    async resetPasswordConfirmation(requestParameters: ResetPasswordConfirmationRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<object> {
        const response = await this.resetPasswordConfirmationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search participants using a user uuid, returns pagination information and list of `items` (ParticipantUserReturn from GET Participant). Can search on \"user_uuid\", and sort on any field. To search enter search value into \"search\" query param and the field into \"search on\" (currently only \"user\"uuid\"). For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: date_created). Max pagination items per page is 50.
     * Searchparticipants
     */
    async searchParticipantsRaw(requestParameters: SearchParticipantsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Page>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.searchOn !== undefined) {
            queryParameters['search_on'] = requestParameters.searchOn;
        }

        if (requestParameters.sortOn !== undefined) {
            queryParameters['sort_on'] = requestParameters.sortOn;
        }

        if (requestParameters.sortDesc !== undefined) {
            queryParameters['sort_desc'] = requestParameters.sortDesc;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/participants`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PageFromJSON(jsonValue));
    }

    /**
     * Search participants using a user uuid, returns pagination information and list of `items` (ParticipantUserReturn from GET Participant). Can search on \"user_uuid\", and sort on any field. To search enter search value into \"search\" query param and the field into \"search on\" (currently only \"user\"uuid\"). For sorting fill out \"sort_desc\" field with either true/false and the \"sort_on\" query parameter with column you want to sort on (ex: date_created). Max pagination items per page is 50.
     * Searchparticipants
     */
    async searchParticipants(requestParameters: SearchParticipantsRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Page> {
        const response = await this.searchParticipantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Signup to eHelply, creates a user and default participant behind the scenes. Does not verify email.
     * Signup
     */
    async signupRaw(requestParameters: SignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserSignupReturn>> {
        if (requestParameters.userSignup === null || requestParameters.userSignup === undefined) {
            throw new runtime.RequiredError('userSignup','Required parameter requestParameters.userSignup was null or undefined when calling signup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/sam/users/auth/signup`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSignupToJSON(requestParameters.userSignup),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSignupReturnFromJSON(jsonValue));
    }

    /**
     * Signup to eHelply, creates a user and default participant behind the scenes. Does not verify email.
     * Signup
     */
    async signup(requestParameters: SignupRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserSignupReturn> {
        const response = await this.signupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update participant data given
     * Updateparticipant
     */
    async updateParticipantRaw(requestParameters: UpdateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<ParticipantUserReturn>> {
        if (requestParameters.participantId === null || requestParameters.participantId === undefined) {
            throw new runtime.RequiredError('participantId','Required parameter requestParameters.participantId was null or undefined when calling updateParticipant.');
        }

        if (requestParameters.participantUpdate === null || requestParameters.participantUpdate === undefined) {
            throw new runtime.RequiredError('participantUpdate','Required parameter requestParameters.participantUpdate was null or undefined when calling updateParticipant.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/participants/{participant_id}`.replace(`{${"participant_id"}}`, encodeURIComponent(String(requestParameters.participantId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ParticipantUpdateToJSON(requestParameters.participantUpdate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ParticipantUserReturnFromJSON(jsonValue));
    }

    /**
     * Update participant data given
     * Updateparticipant
     */
    async updateParticipant(requestParameters: UpdateParticipantRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<ParticipantUserReturn> {
        const response = await this.updateParticipantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the given user and sync the cognito data
     * Updateuser
     */
    async updateUserRaw(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateUser.');
        }

        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling updateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserToJSON(requestParameters.user),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Update the given user and sync the cognito data
     * Updateuser
     */
    async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<UserResponse> {
        const response = await this.updateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates a certain field.
     * Uservalidations
     */
    async userValidationsRaw(requestParameters: UserValidationsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters.field === null || requestParameters.field === undefined) {
            throw new runtime.RequiredError('field','Required parameter requestParameters.field was null or undefined when calling userValidations.');
        }

        if (requestParameters.userValidations === null || requestParameters.userValidations === undefined) {
            throw new runtime.RequiredError('userValidations','Required parameter requestParameters.userValidations was null or undefined when calling userValidations.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAccessToken !== undefined && requestParameters.xAccessToken !== null) {
            headerParameters['x-access-token'] = String(requestParameters.xAccessToken);
        }

        if (requestParameters.xSecretToken !== undefined && requestParameters.xSecretToken !== null) {
            headerParameters['x-secret-token'] = String(requestParameters.xSecretToken);
        }

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.ehelplyActiveParticipant !== undefined && requestParameters.ehelplyActiveParticipant !== null) {
            headerParameters['ehelply-active-participant'] = String(requestParameters.ehelplyActiveParticipant);
        }

        if (requestParameters.ehelplyProject !== undefined && requestParameters.ehelplyProject !== null) {
            headerParameters['ehelply-project'] = String(requestParameters.ehelplyProject);
        }

        if (requestParameters.ehelplyData !== undefined && requestParameters.ehelplyData !== null) {
            headerParameters['ehelply-data'] = String(requestParameters.ehelplyData);
        }

        const response = await this.request({
            path: `/sam/users/validations/{field}`.replace(`{${"field"}}`, encodeURIComponent(String(requestParameters.field))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserValidationsToJSON(requestParameters.userValidations),
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Validates a certain field.
     * Uservalidations
     */
    async userValidations(requestParameters: UserValidationsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<boolean> {
        const response = await this.userValidationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
